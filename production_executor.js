/**
 * Áîü‰∫ßÁ≥ªÁªüÊ†∏ÂøÉÊâßË°åÂô®
 * Êï¥ÂêàÊâÄÊúâÂäüËÉΩÔºöÂéüÂßãËΩ¨Ë¥¶ + Enhanced Swap + ÂüüÂêçMint + NFT + Âü∫Á°ÄÂäüËÉΩ
 * 
 * ‰ΩúËÄÖ: 0xTAN
 * Êé®Áâπ: https://X.com/cgyJ9WZV29saahQ
 */

const { ethers } = require('ethers');
const axios = require('axios');
const randomUseragent = require('random-useragent');
const { HttpsProxyAgent } = require('https-proxy-agent');

const { 
    FEATURE_CONFIG, 
    CURRENT_CONFIG, 
    NETWORK_CONFIG,
    getEnabledFeatures,
    getCyclableFeatures,
    getOnceOnlyFeatures,
    getFeatureConfig,
    printCurrentConfig
} = require('./production_config');

const { executeLiquidityAddition } = require('./liquidity_module.js');

const colors = {
    reset: '\x1b[0m', cyan: '\x1b[36m', green: '\x1b[32m',
    yellow: '\x1b[33m', red: '\x1b[31m', white: '\x1b[37m', bold: '\x1b[1m',
};

const logger = {
    info: (msg) => console.log(`${colors.green}[‚úì] ${msg}${colors.reset}`),
    warn: (msg) => console.log(`${colors.yellow}[!] ${msg}${colors.reset}`),
    error: (msg) => console.log(`${colors.red}[‚úó] ${msg}${colors.reset}`),
    success: (msg) => console.log(`${colors.green}[+] ${msg}${colors.reset}`),
    loading: (msg) => console.log(`${colors.cyan}[‚ü≥] ${msg}${colors.reset}`),
    step: (msg) => console.log(`${colors.white}[‚û§] ${msg}${colors.reset}`),
    wallet: (msg) => console.log(`${colors.yellow}[üëõ] ${msg}${colors.reset}`),
    cycle: (msg) => console.log(`${colors.bold}${colors.cyan}[üîÑ] ${msg}${colors.reset}`),
};

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ===== ABI ÂÆö‰πâ =====
const erc20ABI = [
    'function balanceOf(address) view returns (uint256)',
    'function allowance(address owner, address spender) view returns (uint256)',
    'function approve(address spender, uint256 amount) public returns (bool)',
];

const wphrsABI = [
    ...erc20ABI,
    'function deposit() payable'
];

const nftABI = [
    {
        "inputs": [
            { "internalType": "address", "name": "_receiver", "type": "address" },
            { "internalType": "uint256", "name": "_quantity", "type": "uint256" },
            { "internalType": "address", "name": "_currency", "type": "address" },
            { "internalType": "uint256", "name": "_pricePerToken", "type": "uint256" },
            {
                "components": [
                    { "internalType": "bytes32[]", "name": "proof", "type": "bytes32[]" },
                    { "internalType": "uint256", "name": "quantityLimitPerWallet", "type": "uint256" },
                    { "internalType": "uint256", "name": "pricePerToken", "type": "uint256" },
                    { "internalType": "address", "name": "currency", "type": "address" }
                ],
                "internalType": "struct ITokenGatedDrop.AllowlistProof",
                "name": "_allowlistProof",
                "type": "tuple"
            },
            { "internalType": "bytes", "name": "_data", "type": "bytes" }
        ],
        "name": "claim",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    }
];

/**
 * ÈáçËØïÊú∫Âà∂
 */
async function retry(fn, maxRetries = 3, delayMs = 2000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            logger.warn(`ÈáçËØï ${i + 1}/${maxRetries}: ${error.message}`);
            await delay(delayMs);
        }
    }
}

/**
 * Áîü‰∫ßÁ≥ªÁªüÊâßË°åÂô®Á±ª
 */
class ProductionExecutor {
    constructor() {
        this.cycleCount = 0;
        this.totalWalletsProcessed = 0;
        this.onceOnlyCompleted = new Set(); // ËÆ∞ÂΩïÂ∑≤ÂÆåÊàêÁöÑÂçïÊ¨°ÂäüËÉΩ
        this.executionStats = {
            totalCycles: 0,
            totalWallets: 0,
            featureStats: {}
        };
    }

    /**
     * ÊòæÁ§∫Á≥ªÁªüÊ®™ÂπÖ
     */
    showBanner() {
        const banner = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                              ‚ïë
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó         ‚ïë
‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë         ‚ïë
‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë         ‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñÑ‚ñÑ ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë         ‚ïë
‚ïë  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù         ‚ïë
‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ñÄ‚ñÄ‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù          ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                    Pharos Ëá™Âä®ÂåñÁ≥ªÁªü v2.0.0                                 ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                    üß† Êô∫ËÉΩÂ¢ûÂº∫SwapÁ≠ñÁï• | üîÑ Â§öÈí±ÂåÖÊâπÈáèÂ§ÑÁêÜ                   ‚ïë
‚ïë                    üåê ‰ª£ÁêÜÊ±†ÊîØÊåÅ       | üõ°Ô∏è ÂÆåÂñÑÈîôËØØÂ§ÑÁêÜ                     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë                    ‰ΩúËÄÖ: 0xTAN                                               ‚ïë
‚ïë                    Êé®Áâπ: https://X.com/cgyJ9WZV29saahQ                      ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        `;
        
        console.log(`${colors.cyan}${colors.bold}${banner}${colors.reset}`);
        printCurrentConfig();
    }

    /**
     * ÊâßË°åÈ¢ÜÊ∞¥ÂäüËÉΩ - ÂÆåÊï¥ÁâàÊú¨ (‰ªéÂéüÂßãmain.jsÁßªÊ§ç)
     */
    async executeFaucet(wallet, proxy = null) {
        try {
            logger.step(`ÂºÄÂßãÈ¢ÜÂèñÊ∞¥ÈæôÂ§¥ - ${wallet.address}`);
            
            const message = "pharos";
            const signature = await wallet.signMessage(message);
            const loginUrl = `https://api.pharosnetwork.xyz/user/login?address=${wallet.address}&signature=${signature}&invite_code=S6NGMzXSCDBxhnwo`;
            
            const headers = {
                accept: "application/json, text/plain, */*",
                "accept-language": "en-US,en;q=0.8",
                "sec-ch-ua": '"Chromium";v="136", "Brave";v="136", "Not.A/Brand";v="99"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "sec-gpc": "1",
                Referer: "https://testnet.pharosnetwork.xyz/",
                "Referrer-Policy": "strict-origin-when-cross-origin",
                "User-Agent": randomUseragent.getRandom(),
            };

            // ÁôªÂΩïËé∑ÂèñJWT
            const loginResponse = await retry(async () => {
                const res = await axios.post(loginUrl, {}, {
                    headers,
                    httpsAgent: proxy ? new HttpsProxyAgent(proxy) : undefined,
                });
                if (res.status === 403) throw new Error('403 Forbidden: Check API access or proxy');
                return res;
            });

            const jwt = loginResponse.data?.data?.jwt;
            if (!jwt) {
                logger.warn('Ê∞¥ÈæôÂ§¥ÁôªÂΩïÂ§±Ë¥•');
                return { success: false, feature: 'faucet', error: 'ÁôªÂΩïÂ§±Ë¥•' };
            }

            // Ê£ÄÊü•È¢ÜÊ∞¥Áä∂ÊÄÅ
            const statusResponse = await retry(async () => {
                const res = await axios.get(`https://api.pharosnetwork.xyz/faucet/status?address=${wallet.address}`, {
                    headers: { ...headers, authorization: `Bearer ${jwt}` },
                    httpsAgent: proxy ? new HttpsProxyAgent(proxy) : undefined,
                });
                if (res.status === 403) throw new Error('403 Forbidden: Check JWT or API restrictions');
                return res;
            });

            const available = statusResponse.data?.data?.is_able_to_faucet;
            if (!available) {
                const nextAvailable = new Date(statusResponse.data?.data?.avaliable_timestamp * 1000).toLocaleString('en-US', { timeZone: 'Asia/Makassar' });
                logger.warn(`‰ªäÊó•Ê∞¥ÈæôÂ§¥Â∑≤È¢ÜÂèñÔºå‰∏ã‰∏ÄÂèØÁî®Êó∂Èó¥Ôºö${nextAvailable}`);
                return { 
                    success: true, // Ê†áËÆ∞‰∏∫ÊàêÂäüÔºåÂõ†‰∏∫Ëøô‰∏çÊòØÈîôËØØ
                    feature: 'faucet', 
                    message: 'already_claimed',
                    nextAvailable: nextAvailable
                };
            }

            // ÊâßË°åÈ¢ÜÊ∞¥
            const claimResponse = await retry(async () => {
                const res = await axios.post(`https://api.pharosnetwork.xyz/faucet/daily?address=${wallet.address}`, {}, {
                    headers: { ...headers, authorization: `Bearer ${jwt}` },
                    httpsAgent: proxy ? new HttpsProxyAgent(proxy) : undefined,
                });
                if (res.status === 403) throw new Error('403 Forbidden: Check API access or rate limits');
                return res;
            });

            if (claimResponse.data?.code === 0) {
                logger.success('‚úÖ Ê∞¥ÈæôÂ§¥È¢ÜÂèñÊàêÂäü');
                return { 
                    success: true, 
                    feature: 'faucet',
                    message: 'claimed_successfully'
                };
            } else {
                logger.warn(`Ê∞¥ÈæôÂ§¥È¢ÜÂèñÂ§±Ë¥•Ôºö${claimResponse.data?.msg || 'Êú™Áü•ÈîôËØØ'}`);
                return { 
                    success: false, 
                    feature: 'faucet', 
                    error: claimResponse.data?.msg || 'Êú™Áü•ÈîôËØØ' 
                };
            }
            
        } catch (error) {
            logger.error(`È¢ÜÂèñÊ∞¥ÈæôÂ§¥ÂºÇÂ∏∏Ôºö${error.message}`);
            if (error.response) {
                logger.error(`ÂìçÂ∫îËØ¶ÊÉÖÔºö${JSON.stringify(error.response.data, null, 2)}`);
            }
            return { success: false, feature: 'faucet', error: error.message };
        }
    }

    /**
     * ÊâßË°åÁ≠æÂà∞ÂäüËÉΩ
     */
    async executeCheckin(wallet, proxy = null) {
        try {
            logger.step(`ÂºÄÂßãÊØèÊó•Á≠æÂà∞ - ${wallet.address}`);
            
            const message = "pharos";
            const signature = await wallet.signMessage(message);
            const loginUrl = `https://api.pharosnetwork.xyz/user/login?address=${wallet.address}&signature=${signature}&invite_code=S6NGMzXSCDBxhnwo`;
            
            const headers = {
                accept: "application/json, text/plain, */*",
                "accept-language": "en-US,en;q=0.8",
                "sec-ch-ua": '"Chromium";v="136", "Brave";v="136", "Not.A/Brand";v="99"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "sec-gpc": "1",
                Referer: "https://testnet.pharosnetwork.xyz/",
                "Referrer-Policy": "strict-origin-when-cross-origin",
                "User-Agent": randomUseragent.getRandom(),
            };

            const loginRes = await retry(async () => {
                const res = await axios.post(loginUrl, {}, {
                    headers,
                    httpsAgent: proxy ? new HttpsProxyAgent(proxy) : undefined,
                });
                if (res.status === 403) throw new Error('403 Forbidden: Check API access or proxy');
                return res;
            });

            const jwt = loginRes.data?.data?.jwt;
            if (!jwt) {
                throw new Error('Á≠æÂà∞ÁôªÂΩïÂ§±Ë¥•');
            }

            const signRes = await retry(async () => {
                const res = await axios.post(`https://api.pharosnetwork.xyz/sign/in?address=${wallet.address}`, {}, {
                    headers: { ...headers, authorization: `Bearer ${jwt}` },
                    httpsAgent: proxy ? new HttpsProxyAgent(proxy) : undefined,
                });
                if (res.status === 403) throw new Error('403 Forbidden: Check JWT or API restrictions');
                return res;
            });

            if (signRes.data?.code === 0) {
                logger.success('‚úÖ Á≠æÂà∞ÊàêÂäü');
                return { success: true, feature: 'checkin' };
            } else {
                throw new Error(`Á≠æÂà∞Â§±Ë¥•Ôºö${signRes.data?.msg || 'Êú™Áü•ÈîôËØØ'}`);
            }
            
        } catch (error) {
            logger.error(`Á≠æÂà∞ÂäüËÉΩÂ§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'checkin', error: error.message };
        }
    }

    /**
     * ÊâßË°åÂéüÂßãËΩ¨Ë¥¶ÂäüËÉΩ (Êù•Ëá™main.js)
     */
    async executeOriginalTransfer(wallet, provider) {
        try {
            const config = getFeatureConfig('originalTransfer').config;
            logger.step(`ÂºÄÂßãÊâßË°åÂéüÂßãPHRSÈöèÊú∫ËΩ¨Ë¥¶ (${config.transferCount}Ê¨°)`);
            
            let successCount = 0;
            
            for (let i = 0; i < config.transferCount; i++) {
                try {
                    const to = ethers.Wallet.createRandom().address;
                    const balance = await provider.getBalance(wallet.address);
                    const required = ethers.utils.parseEther(config.transferAmount.toString());
                    const requiredWithGas = required.add(ethers.utils.parseEther("0.001"));
                    
                    if (balance.lt(requiredWithGas)) {
                        logger.warn(`PHRS‰ΩôÈ¢ù‰∏çË∂≥ÔºåÁªàÊ≠¢ËΩ¨Ë¥¶‰ªªÂä°`);
                        break;
                    }

                    const tx = await wallet.sendTransaction({
                        to,
                        value: required,
                        gasLimit: config.gasLimit,
                        gasPrice: config.gasPrice,
                    });
                    
                    logger.loading(`ÈöèÊú∫ËΩ¨Ë¥¶ ${i + 1}/${config.transferCount} Âà∞ ${to.slice(0,10)}... | TX: ${tx.hash}`);
                    await tx.wait();
                    logger.success(`ÈöèÊú∫ËΩ¨Ë¥¶ ${i + 1}/${config.transferCount} ÊàêÂäü!`);
                    successCount++;
                    
                    await delay(1000 + Math.random() * 2000);
                } catch (error) {
                    logger.error(`ËΩ¨Ë¥¶ ${i + 1} Â§±Ë¥•: ${error.message}`);
                }
            }
            
            logger.success(`‚úÖ ÂéüÂßãËΩ¨Ë¥¶ÂÆåÊàê: ${successCount}/${config.transferCount} ÊàêÂäü`);
            return { 
                success: successCount > 0, 
                feature: 'originalTransfer',
                details: { successCount, totalCount: config.transferCount }
            };
            
        } catch (error) {
            logger.error(`ÂéüÂßãËΩ¨Ë¥¶ÂäüËÉΩÂ§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'originalTransfer', error: error.message };
        }
    }

    /**
     * ÊâßË°åPHRSÂåÖË£ÖÂäüËÉΩ
     */
    async executeWrapPHRS(wallet, provider) {
        try {
            const config = getFeatureConfig('wrapPHRS').config;
            logger.step("ÊâßË°åPHRSÂåÖË£Ö");
            
            const wphrsAddress = NETWORK_CONFIG.tokens.WPHRS.address;
            const wphrsContract = new ethers.Contract(wphrsAddress, wphrsABI, wallet);
            
            const currentBalance = await wphrsContract.balanceOf(wallet.address);
            const minBalance = ethers.utils.parseEther(config.minBalance.toString());
            
            if (currentBalance.lt(minBalance)) {
                const wrapAmount = ethers.utils.parseEther(config.wrapAmount.toString());
                const tx = await wphrsContract.deposit({ value: wrapAmount });
                await tx.wait();
                logger.success(`‚úÖ ÂåÖË£Ö‰∫Ü ${config.wrapAmount} PHRS`);
            } else {
                logger.info("WPHRS‰ΩôÈ¢ùÂÖÖË∂≥ÔºåË∑≥ËøáÂåÖË£Ö");
            }
            
            return { success: true, feature: 'wrapPHRS' };
            
        } catch (error) {
            logger.error(`PHRSÂåÖË£ÖÂ§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'wrapPHRS', error: error.message };
        }
    }

    /**
     * ÊâßË°åÂ¢ûÂº∫ÁâàSwapÂäüËÉΩ (‰∏ªË¶ÅSwapÂäüËÉΩ)
     */
    async executeEnhancedSwap(wallet, provider) {
        try {
            logger.step("ÊâßË°åÂ¢ûÂº∫ÁâàSwap (‰∏ªË¶ÅSwapÂäüËÉΩ)");
            
            // Ëé∑ÂèñÈÖçÁΩÆ
            const config = getFeatureConfig('enhancedSwap').config;
            const contracts = config.contracts;
            const swapsPerContract = config.swapsPerContract;
            
            // ‰∫§ÊòìÂØπÈÖçÁΩÆ
            const TRADING_PAIRS = [
                { from: 'WPHRS', to: 'USDC', baseAmount: 0.001, weight: 3 },
                { from: 'WPHRS', to: 'USDT', baseAmount: 0.001, weight: 3 },
                { from: 'USDC', to: 'USDT', baseAmount: 0.1, weight: 2 },
                { from: 'USDT', to: 'USDC', baseAmount: 0.1, weight: 2 },
                { from: 'USDC', to: 'WPHRS', baseAmount: 0.1, weight: 2 },
                { from: 'USDT', to: 'WPHRS', baseAmount: 0.1, weight: 2 },
                { from: 'WPHRS', to: 'USDC', baseAmount: 0.0005, weight: 1 },
                { from: 'WPHRS', to: 'USDT', baseAmount: 0.0005, weight: 1 },
                { from: 'USDC', to: 'WPHRS', baseAmount: 0.05, weight: 1 },
                { from: 'USDT', to: 'WPHRS', baseAmount: 0.05, weight: 1 },
            ];

            const multicallABI = [
                {
                    "inputs": [
                        {"internalType": "uint256", "name": "deadline", "type": "uint256"},
                        {"internalType": "bytes[]", "name": "data", "type": "bytes[]"}
                    ],
                    "name": "multicall",
                    "outputs": [],
                    "stateMutability": "payable",
                    "type": "function"
                }
            ];

            const tokens = NETWORK_CONFIG.tokens;
            
            logger.info(`üéØ ÂØπ ${contracts.length} ‰∏™ÂêàÁ∫¶ÂêÑÊâßË°å ${swapsPerContract} Ê¨°swap`);
            
            // Ê£ÄÊü•‰ΩôÈ¢ù
            const balance = await provider.getBalance(wallet.address);
            const balanceEth = ethers.utils.formatEther(balance);
            logger.info(`üí∞ PHRS‰ΩôÈ¢ù: ${balanceEth}`);
            
            if (balance.lt(ethers.utils.parseEther("0.01"))) {
                throw new Error(`PHRS‰ΩôÈ¢ù‰∏çË∂≥: ${balanceEth}`);
            }

            let totalSwaps = 0;
            let successfulSwaps = 0;
            let usedPairs = [];

            // ËæÖÂä©ÂáΩÊï∞ÔºöÈÄâÊã©‰∫§ÊòìÂØπ
            const selectTradingPair = async () => {
                const availablePairs = [];
                
                for (const pair of TRADING_PAIRS) {
                    try {
                        const token = tokens[pair.from];
                        if (!token) continue;
                        
                        const tokenContract = new ethers.Contract(token.address, erc20ABI, provider);
                        const tokenBalance = await tokenContract.balanceOf(wallet.address);
                        const requiredAmount = ethers.utils.parseUnits(pair.baseAmount.toString(), token.decimals);
                        
                        if (tokenBalance.gte(requiredAmount)) {
                            availablePairs.push(pair);
                        }
                    } catch (error) {
                        // ÂøΩÁï•‰ΩôÈ¢ùÊ£ÄÊü•ÈîôËØØÔºåÁªßÁª≠‰∏ã‰∏Ä‰∏™
                        continue;
                    }
                }

                if (availablePairs.length === 0) return null;

                // ÈÅøÂÖçËøûÁª≠‰ΩøÁî®Áõ∏Âêå‰∫§ÊòìÂØπ
                const recentPairKey = usedPairs.slice(-2).join(',');
                const diversePairs = availablePairs.filter(pair => {
                    const pairKey = `${pair.from}-${pair.to}`;
                    return !recentPairKey.includes(pairKey);
                });

                const finalPairs = diversePairs.length > 0 ? diversePairs : availablePairs;
                
                // Ê†πÊçÆÊùÉÈáçÈöèÊú∫ÈÄâÊã©
                const totalWeight = finalPairs.reduce((sum, pair) => sum + pair.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const pair of finalPairs) {
                    random -= pair.weight;
                    if (random <= 0) {
                        return pair;
                    }
                }

                return finalPairs[0];
            };

            // ÂØπÊØè‰∏™ÂêàÁ∫¶ÊâßË°åswap
            for (let contractIndex = 0; contractIndex < contracts.length; contractIndex++) {
                const contractAddr = contracts[contractIndex];
                const contract = new ethers.Contract(contractAddr, multicallABI, wallet);
                
                logger.info(`\nüéØ Â§ÑÁêÜÂêàÁ∫¶ ${contractIndex + 1}: ${contractAddr.slice(0, 8)}...`);
                
                for (let swapIndex = 1; swapIndex <= swapsPerContract; swapIndex++) {
                    try {
                        // ÈÄâÊã©‰∫§ÊòìÂØπ
                        const pair = await selectTradingPair();
                        if (!pair) {
                            logger.warn(`Êó†ÂèØÁî®‰∫§ÊòìÂØπÔºåË∑≥ËøáÂâ©‰Ωôswap`);
                            break;
                        }

                        logger.step(`[${contractIndex + 1}] ${pair.from} ‚Üí ${pair.to} (${swapIndex}/${swapsPerContract})`);

                        // ÈöèÊú∫Âåñ‰∫§ÊòìÈáëÈ¢ù
                        const amountMultiplier = 0.7 + Math.random() * 0.6;
                        const token = tokens[pair.from];
                        const randomizedAmount = pair.baseAmount * amountMultiplier;
                        const amount = ethers.utils.parseUnits(randomizedAmount.toFixed(token.decimals), token.decimals);

                        logger.info(`üí∞ ‰∫§ÊòìÈáëÈ¢ù: ${randomizedAmount.toFixed(6)} ${pair.from}`);

                        // Ê£ÄÊü•Âπ∂ÊéàÊùÉ
                        const tokenContract = new ethers.Contract(token.address, erc20ABI, wallet);
                        const allowance = await tokenContract.allowance(wallet.address, contractAddr);
                        
                        if (allowance.lt(amount)) {
                            logger.loading("ÊéàÊùÉ‰ª£Â∏Å...");
                            const approveTx = await tokenContract.approve(contractAddr, ethers.constants.MaxUint256);
                            await approveTx.wait();
                            logger.success("‚úÖ ÊéàÊùÉÊàêÂäü");
                            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
                        }

                        // ÊûÑÈÄ†swapÊï∞ÊçÆ
                        const swapData = ethers.utils.defaultAbiCoder.encode(
                            ['address', 'address', 'uint24', 'address', 'uint256', 'uint256', 'uint256'],
                            [
                                tokens[pair.from].address,
                                tokens[pair.to].address,
                                500, // ÊâãÁª≠Ë¥πÁéá
                                wallet.address,
                                amount,
                                0, // amountOutMin
                                0  // deadline
                            ]
                        );

                        const fullData = ethers.utils.concat(["0x04e45aaf", swapData]);

                        // ÊâßË°å‰∫§Êòì
                        logger.loading(`ÂèëÈÄÅ‰∫§ÊòìÂà∞ÂêàÁ∫¶ ${contractAddr.slice(0, 8)}...`);
                        const tx = await contract.multicall(
                            Math.floor(Date.now() / 1000) + 300,
                            [fullData],
                            {
                                gasLimit: Math.floor(Math.random() * 40000) + 480000,
                                gasPrice: 0
                            }
                        );

                        logger.loading(`Á≠âÂæÖÁ°ÆËÆ§: ${tx.hash}`);
                        const receipt = await tx.wait();

                        if (receipt.status === 1) {
                            logger.success(`‚úÖ SwapÊàêÂäü: ${tx.hash.slice(0, 10)}...`);
                            successfulSwaps++;
                            
                            // ËÆ∞ÂΩï‰ΩøÁî®ÁöÑ‰∫§ÊòìÂØπ
                            usedPairs.push(`${pair.from}-${pair.to}`);
                            if (usedPairs.length > 10) {
                                usedPairs.shift();
                            }
                        } else {
                            logger.error(`‚ùå SwapÂ§±Ë¥•ÔºåÁä∂ÊÄÅ: ${receipt.status}`);
                        }

                        totalSwaps++;
                        
                        // ‰∫§ÊòìÈó¥Âª∂Ëøü
                        const delay = Math.floor(Math.random() * 3000) + 2000;
                        await new Promise(resolve => setTimeout(resolve, delay));

                    } catch (error) {
                        logger.error(`Swap ${swapIndex} Â§±Ë¥•: ${error.message}`);
                        totalSwaps++;
                    }
                }

                // ÂêàÁ∫¶Èó¥Âª∂Ëøü
                if (contractIndex < contracts.length - 1) {
                    logger.info("‚è≥ ÂêàÁ∫¶Èó¥Âª∂Ëøü...");
                    await new Promise(resolve => setTimeout(resolve, 3000 + Math.random() * 3000));
                }
            }

            // ËæìÂá∫ÊÄªÁªì
            logger.info(`\nüìä SwapÊâßË°åÊÄªÁªì:`);
            logger.info(`üì§ ÊÄª‰∫§ÊòìÊï∞: ${totalSwaps}`);
            logger.info(`‚úÖ ÊàêÂäü: ${successfulSwaps}`);
            logger.info(`‚ùå Â§±Ë¥•: ${totalSwaps - successfulSwaps}`);
            logger.info(`üìà ÊàêÂäüÁéá: ${totalSwaps > 0 ? ((successfulSwaps / totalSwaps) * 100).toFixed(1) : 0}%`);

            logger.success("‚úÖ Â¢ûÂº∫ÁâàSwapÊâßË°åÂÆåÊàê");
            
            return { 
                success: true, 
                feature: 'enhancedSwap',
                totalSwaps: totalSwaps,
                successfulSwaps: successfulSwaps,
                successRate: totalSwaps > 0 ? ((successfulSwaps / totalSwaps) * 100).toFixed(1) : 0
            };
            
        } catch (error) {
            logger.error(`Â¢ûÂº∫ÁâàSwapÂ§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'enhancedSwap', error: error.message };
        }
    }

    /**
     * ÊâßË°åÂüüÂêçMintÂäüËÉΩ
     */
    async executeDomainMint(wallet, provider) {
        try {
            logger.step("ÊâßË°åÂüüÂêçMint");
            
            // ÂÆåÊï¥ÁöÑÂüüÂêçÂêàÁ∫¶ABI
            const DOMAIN_CONTRACT_ABI = [
                {
                    "inputs": [{"internalType": "bytes32", "name": "commitment", "type": "bytes32"}],
                    "name": "commit", 
                    "outputs": [], 
                    "stateMutability": "nonpayable", 
                    "type": "function"
                },
                {
                    "inputs": [
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "uint256", "name": "duration", "type": "uint256"}
                    ],
                    "name": "rentPrice", 
                    "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], 
                    "stateMutability": "view", 
                    "type": "function"
                },
                {
                    "inputs": [
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "address", "name": "owner", "type": "address"},
                        {"internalType": "uint256", "name": "duration", "type": "uint256"},
                        {"internalType": "bytes32", "name": "secret", "type": "bytes32"},
                        {"internalType": "address", "name": "resolver", "type": "address"},
                        {"internalType": "bytes[]", "name": "data", "type": "bytes[]"},
                        {"internalType": "bool", "name": "reverseRecord", "type": "bool"},
                        {"internalType": "uint16", "name": "fuses", "type": "uint16"}
                    ],
                    "name": "register",
                    "outputs": [],
                    "stateMutability": "payable",
                    "type": "function"
                },
                {
                    "inputs": [
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "address", "name": "owner", "type": "address"},
                        {"internalType": "uint256", "name": "duration", "type": "uint256"},
                        {"internalType": "bytes32", "name": "secret", "type": "bytes32"},
                        {"internalType": "address", "name": "resolver", "type": "address"},
                        {"internalType": "bytes[]", "name": "data", "type": "bytes[]"},
                        {"internalType": "bool", "name": "reverseRecord", "type": "bool"},
                        {"internalType": "uint16", "name": "fuses", "type": "uint16"}
                    ],
                    "name": "makeCommitment",
                    "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
                    "stateMutability": "pure",
                    "type": "function"
                }
            ];
            
            // ÂüüÂêçÊ≥®ÂÜåÈÖçÁΩÆ
            const domainConfig = getFeatureConfig('domainMint').config;
            const contractAddress = domainConfig.contractAddress;
            const resolver = domainConfig.resolver;
            const duration = domainConfig.duration;
            
            // ÁîüÊàêÈöèÊú∫ÂüüÂêç
            const generateRandomDomainName = (length = 10) => {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            };
            
            const domainName = generateRandomDomainName();
            const secret = ethers.utils.randomBytes(32);
            const secretHex = ethers.utils.hexlify(secret);
            const data = [];
            const reverseRecord = false;
            const fuses = 0;
            
            const contract = new ethers.Contract(contractAddress, DOMAIN_CONTRACT_ABI, wallet);
            
            logger.info(`üéØ Ê≥®ÂÜåÂüüÂêç: ${domainName}.phrs`);
            logger.info(`üìç Èí±ÂåÖÂú∞ÂùÄ: ${wallet.address}`);
            
            // Ê£ÄÊü•‰ΩôÈ¢ù
            const balance = await provider.getBalance(wallet.address);
            const balanceEth = ethers.utils.formatEther(balance);
            logger.info(`üí∞ Èí±ÂåÖ‰ΩôÈ¢ù: ${balanceEth} PHRS`);
            
            if (balance.lt(ethers.utils.parseEther("0.01"))) {
                throw new Error(`‰ΩôÈ¢ù‰∏çË∂≥: ${balanceEth} PHRS`);
            }
            
            // Step 1: ‰ΩøÁî®makeCommitmentËÆ°ÁÆóÊ≠£Á°ÆÁöÑcommitment
            logger.step("ËÆ°ÁÆócommitment...");
            const commitment = await contract.makeCommitment(
                domainName, wallet.address, duration, secretHex, 
                resolver, data, reverseRecord, fuses
            );
            logger.info(`‚úÖ Commitment: ${commitment}`);
            
            // Step 2: ÂèëÈÄÅcommit‰∫§Êòì
            logger.step("ÂèëÈÄÅcommit‰∫§Êòì...");
            const commitTx = await contract.commit(commitment, {
                gasLimit: 100000,
                gasPrice: ethers.utils.parseUnits("1", "gwei")
            });
            logger.info(`üì§ Commit‰∫§Êòì: ${commitTx.hash}`);
            
            // Á≠âÂæÖcommitÁ°ÆËÆ§
            const commitReceipt = await provider.waitForTransaction(commitTx.hash, 1, 180000);
            if (commitReceipt.status !== 1) {
                throw new Error("Commit‰∫§ÊòìÂ§±Ë¥•");
            }
            logger.success("‚úÖ Commit‰∫§ÊòìÁ°ÆËÆ§ÊàêÂäü");
            
            // Step 3: Á≠âÂæÖÊúÄÂ∞ècommitmentÂπ¥ÈæÑ
            logger.step("Á≠âÂæÖ60Áßí...");
            await new Promise(resolve => setTimeout(resolve, 62000));
            
            // Step 4: Ëé∑Âèñ‰ª∑Ê†ºÂπ∂Ê≥®ÂÜå
            logger.step("Ëé∑Âèñ‰ª∑Ê†ºÂπ∂Ê≥®ÂÜå...");
            const priceInfo = await contract.rentPrice(domainName, duration);
            const priceEth = ethers.utils.formatEther(priceInfo);
            logger.info(`üí∞ ÂüüÂêç‰ª∑Ê†º: ${priceEth} PHRS`);
            
            const registerTx = await contract.register(
                domainName, wallet.address, duration, secretHex,
                resolver, data, reverseRecord, fuses,
                {
                    value: priceInfo,
                    gasLimit: 500000,
                    gasPrice: ethers.utils.parseUnits("1", "gwei")
                }
            );
            logger.info(`üì§ Register‰∫§Êòì: ${registerTx.hash}`);
            
            // Á≠âÂæÖregisterÁ°ÆËÆ§
            const registerReceipt = await provider.waitForTransaction(registerTx.hash, 1, 180000);
            
            if (registerReceipt.status === 1) {
                logger.success(`üéâ ÂüüÂêçÊ≥®ÂÜåÊàêÂäü: ${domainName}.phrs`);
                logger.success(`üì§ Commit‰∫§Êòì: ${commitTx.hash}`);
                logger.success(`üì§ Register‰∫§Êòì: ${registerTx.hash}`);
                logger.success(`‚õΩ Gas‰ΩøÁî®: ${registerReceipt.gasUsed.toString()}`);
                logger.success(`üí∞ Ê≥®ÂÜå‰ª∑Ê†º: ${priceEth} PHRS`);
                
                return { 
                    success: true, 
                    feature: 'domainMint',
                    domainName: domainName,
                    commitTxHash: commitTx.hash,
                    registerTxHash: registerTx.hash,
                    gasUsed: registerReceipt.gasUsed.toString(),
                    price: priceEth
                };
            } else {
                throw new Error("Register‰∫§ÊòìÂ§±Ë¥•");
            }
            
        } catch (error) {
            logger.error(`ÂüüÂêçMintÂ§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'domainMint', error: error.message };
        }
    }

    /**
     * ÊâßË°åNFTÈì∏ÈÄ†ÂäüËÉΩ
     */
    async executeNFTMint(wallet, provider) {
        try {
            const config = getFeatureConfig('nftMint').config;
            logger.step("ÊâßË°åNFTÈì∏ÈÄ†");
            
            const nftContract = new ethers.Contract(config.contractAddress, nftABI, wallet);
            
            // Ê£ÄÊü•ÂêàÁ∫¶‰ª£Á†ÅÊòØÂê¶Â≠òÂú®
            const code = await provider.getCode(config.contractAddress);
            if (code === '0x') {
                throw new Error(`NFTÂêàÁ∫¶Âú∞ÂùÄ ${config.contractAddress} ‰∏çÂ≠òÂú®ÊàñÊú™ÈÉ®ÁΩ≤`);
            }
            logger.info(`‚úÖ NFTÂêàÁ∫¶‰ª£Á†ÅÈ™åËØÅÈÄöËøá`);

            // ÊûÑÂª∫‰∫§ÊòìÂèÇÊï∞
            const receiver = wallet.address;
            const quantity = config.mintAmount || 1;
            const currency = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'; // ÂéüÁîü‰ª£Â∏ÅÂú∞ÂùÄ
            const pricePerToken = ethers.utils.parseEther("1"); // 1 PHRS ‰ª∑Ê†º
            
            const allowlistProof = {
                proof: [],
                quantityLimitPerWallet: ethers.constants.MaxUint256,
                pricePerToken: 0,
                currency: '0x0000000000000000000000000000000000000000'
            };
            const data = '0x';
            
            const txValue = pricePerToken.mul(quantity);
            
            // Ê£ÄÊü•‰ΩôÈ¢ù
            const balance = await provider.getBalance(wallet.address);
            const balanceEth = ethers.utils.formatEther(balance);
            const requiredEth = ethers.utils.formatEther(txValue);
            
            logger.info(`üí∞ Èí±ÂåÖ‰ΩôÈ¢ù: ${balanceEth} PHRS`);
            logger.info(`üéØ NFT‰ª∑Ê†º: ${requiredEth} PHRS`);
            
            if (balance.lt(txValue)) {
                throw new Error(`‰ΩôÈ¢ù‰∏çË∂≥ (${balanceEth} PHRS)ÔºåÈúÄË¶Å ${requiredEth} PHRS`);
            }

            // Ê®°Êãü‰∫§Êòì
            try {
                logger.step("Ê≠£Âú®Ê®°Êãü‰∫§Êòì...");
                await nftContract.callStatic.claim(
                    receiver,
                    quantity,
                    currency,
                    pricePerToken,
                    allowlistProof,
                    data,
                    { value: txValue, gasLimit: 500000, gasPrice: 0 }
                );
                logger.success("‚úÖ ‰∫§ÊòìÊ®°ÊãüÊàêÂäü");
            } catch (simError) {
                logger.error(`‰∫§ÊòìÊ®°ÊãüÂ§±Ë¥•: ${simError.reason || simError.message}`);
                if (simError.data) {
                    try {
                        const decodedError = nftContract.interface.parseError(simError.data);
                        logger.error(`ÂêàÁ∫¶ÈîôËØØËØ¶ÊÉÖ: ${decodedError.name}`);
                    } catch {}
                }
                throw new Error(`NFTÈì∏ÈÄ†Ê®°ÊãüÂ§±Ë¥•: ${simError.reason || simError.message}`);
            }

            // ÂèëÈÄÅÁúüÂÆû‰∫§Êòì
            logger.loading("Ê≠£Âú®ÂèëÈÄÅÈì∏ÈÄ†‰∫§Êòì...");
            const tx = await nftContract.claim(
                receiver,
                quantity,
                currency,
                pricePerToken,
                allowlistProof,
                data,
                {
                    value: txValue,
                    gasLimit: 500000,
                    gasPrice: 0,
                }
            );

            logger.loading(`Á≠âÂæÖÁ°ÆËÆ§: ${tx.hash}`);
            const receipt = await tx.wait();

            if (receipt.status === 1) {
                logger.success(`üéâ NFTÈì∏ÈÄ†ÊàêÂäü!`);
                logger.success(`üì§ ‰∫§ÊòìÂìàÂ∏å: ${tx.hash}`);
                logger.success(`‚õΩ Gas‰ΩøÁî®: ${receipt.gasUsed.toString()}`);
                logger.success(`üí∞ ÊîØ‰ªò‰ª∑Ê†º: ${requiredEth} PHRS`);
                
                return { 
                    success: true, 
                    feature: 'nftMint',
                    txHash: tx.hash,
                    gasUsed: receipt.gasUsed.toString(),
                    price: requiredEth,
                    quantity: quantity
                };
            } else {
                throw new Error(`NFTÈì∏ÈÄ†Â§±Ë¥•Ôºå‰∫§ÊòìÁä∂ÊÄÅ: ${receipt.status}`);
            }
            
        } catch (error) {
            logger.error(`NFTÈì∏ÈÄ†Â§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'nftMint', error: error.message };
        }
    }

    /**
     * ÊâßË°åÊµÅÂä®ÊÄßÊ∑ªÂä†ÂäüËÉΩ
     */
    async executeLiquidityAdd(wallet, provider) {
        try {
            logger.step("ÊâßË°åÂ§öÊ±†ÊµÅÂä®ÊÄßÊ∑ªÂä†");
            
            // Ëé∑ÂèñÈÖçÁΩÆ
            const liquidityConfig = getFeatureConfig('liquidityAdd').config;
            const maxPools = liquidityConfig.maxPoolsPerCycle || 3;
            
            logger.info(`üéØ ÁõÆÊ†á: ÊúÄÂ§öÊ∑ªÂä† ${maxPools} ‰∏™ÊµÅÂä®ÊÄßÊ±†`);
            
            // Ë∞ÉÁî®ÊµÅÂä®ÊÄßÊ®°ÂùóÔºàÊîØÊåÅÂ§öÊ±†Ôºâ
            const result = await executeLiquidityAddition(wallet, provider, maxPools);
            
            if (result.success) {
                logger.success(`üéâ Â§öÊ±†ÊµÅÂä®ÊÄßÊ∑ªÂä†ÂÆåÊàê!`);
                logger.success(`üìä ÊàêÂäü: ${result.successfulPools}/${result.totalPools} ‰∏™Ê±†`);
                
                if (result.successfulTxs && result.successfulTxs.length > 0) {
                    logger.success(`üì§ ÊàêÂäüÁöÑ‰∫§Êòì:`);
                    result.successfulTxs.forEach((hash, index) => {
                        logger.success(`   ${index + 1}. ${hash}`);
                    });
                }
                
                // ÁªüËÆ°‰ø°ÊÅØ
                const successfulResults = result.results.filter(r => r.success);
                if (successfulResults.length > 0) {
                    logger.success(`üí∞ Ê∑ªÂä†ËØ¶ÊÉÖ:`);
                    successfulResults.forEach((res, index) => {
                        logger.success(`   ${index + 1}. ${res.pool}: ${res.amount0} + ${res.amount1}`);
                    });
                }
                
                return {
                    success: true,
                    feature: 'liquidityAdd',
                    totalPools: result.totalPools,
                    successfulPools: result.successfulPools,
                    successfulTxs: result.successfulTxs,
                    results: result.results
                };
            } else {
                throw new Error(result.error);
            }
            
        } catch (error) {
            logger.error(`ÊµÅÂä®ÊÄßÊ∑ªÂä†Â§±Ë¥•: ${error.message}`);
            return { success: false, feature: 'liquidityAdd', error: error.message };
        }
    }

    /**
     * Â§ÑÁêÜÂçï‰∏™Èí±ÂåÖÁöÑÊâÄÊúâÂäüËÉΩ
     */
    async processWallet(privateKey, proxy = null) {
        const provider = new ethers.providers.JsonRpcProvider(NETWORK_CONFIG.rpcUrl);
        const wallet = new ethers.Wallet(privateKey, provider);
        
        logger.wallet(`ÂºÄÂßãÂ§ÑÁêÜÈí±ÂåÖ: ${wallet.address}`);
        
        const walletResults = {
            address: wallet.address,
            results: [],
            totalFeatures: 0,
            successfulFeatures: 0,
            failedFeatures: 0
        };

        // Ëé∑ÂèñÈúÄË¶ÅÊâßË°åÁöÑÂäüËÉΩ - Áé∞Âú®ÂüüÂêçÊ≥®ÂÜå‰πüÊòØÂæ™ÁéØÂäüËÉΩ‰∫Ü
        const cyclableFeatures = getCyclableFeatures();
        const onceOnlyFeatures = getOnceOnlyFeatures().filter(f => 
            !this.onceOnlyCompleted.has(f)
        );
        
        const allFeatures = [...cyclableFeatures, ...onceOnlyFeatures];
        walletResults.totalFeatures = allFeatures.length;

        for (const featureName of allFeatures) {
            try {
                logger.info(`\nüéØ ÊâßË°åÂäüËÉΩ: ${getFeatureConfig(featureName).name}`);
                
                let result;
                
                switch (featureName) {
                    case 'faucet':
                        result = await this.executeFaucet(wallet, proxy);
                        break;
                    case 'checkin':
                        result = await this.executeCheckin(wallet, proxy);
                        break;
                    case 'originalTransfer':
                        result = await this.executeOriginalTransfer(wallet, provider);
                        break;
                    case 'wrapPHRS':
                        result = await this.executeWrapPHRS(wallet, provider);
                        break;
                    case 'enhancedSwap':
                        result = await this.executeEnhancedSwap(wallet, provider);
                        break;
                    case 'domainMint':
                        result = await this.executeDomainMint(wallet, provider);
                        break;
                    case 'nftMint':
                        result = await this.executeNFTMint(wallet, provider);
                        break;
                    case 'liquidityAdd':
                        result = await this.executeLiquidityAdd(wallet, provider);
                        break;
                    default:
                        logger.warn(`Êú™Áü•ÂäüËÉΩ: ${featureName}`);
                        continue;
                }

                walletResults.results.push(result);
                
                if (result.success) {
                    walletResults.successfulFeatures++;
                    
                    // Âè™ÊúâÁúüÊ≠£ÁöÑÂçïÊ¨°ÂäüËÉΩÊâçÊ†áËÆ∞‰∏∫Â∑≤ÂÆåÊàê (Áé∞Âú®‰∏ªË¶ÅÊòØNFT)
                    if (!getFeatureConfig(featureName).cycleEnabled) {
                        this.onceOnlyCompleted.add(featureName);
                    }
                } else {
                    walletResults.failedFeatures++;
                }

                // ÂäüËÉΩÈó¥Âª∂Ëøü
                await delay(CURRENT_CONFIG.wallet.delayBetweenFeatures);

            } catch (error) {
                logger.error(`ÂäüËÉΩ ${featureName} ÊâßË°åÂºÇÂ∏∏: ${error.message}`);
                walletResults.results.push({
                    success: false,
                    feature: featureName,
                    error: error.message
                });
                walletResults.failedFeatures++;
            }
        }

        // ËæìÂá∫Èí±ÂåÖÂ§ÑÁêÜÁªìÊûú
        const successRate = walletResults.totalFeatures > 0 ? 
            ((walletResults.successfulFeatures / walletResults.totalFeatures) * 100).toFixed(1) : 0;
        
        logger.wallet(`Èí±ÂåÖ ${wallet.address.slice(0, 8)}... Â§ÑÁêÜÂÆåÊàê:`);
        logger.info(`  ÊàêÂäü: ${walletResults.successfulFeatures}/${walletResults.totalFeatures} (${successRate}%)`);

        return walletResults;
    }
}

module.exports = { ProductionExecutor };
